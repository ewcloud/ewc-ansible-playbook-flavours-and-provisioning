---
- name: Prompt for user inputs
  hosts: localhost
  connection: local
  gather_facts: false

  vars_prompt:
    - name: ewc_provider
      prompt: choose your target EWC provider to be either 'ecmwf' or 'eumetsat'
      private: false

    - name: tf_project_path
      prompt: path to terraform working directory
      private: false

    - name: app_name
      prompt: application name, used as prefix in the full instance name
      private: false

    - name: instance_name
      prompt: name of the instance, used in the full instance name
      private: false

    - name: instance_index
      prompt: index or identifier for the instance, used as suffix in the full instance name
      private: false

    - name: flavor_name
      prompt: name the flavor to use for the instance
      private: false

    - name: image_name
      prompt: name the image to use for the instance
      private: false

    - name: public_keypair_name
      prompt: name of public keypair (stored in OpenStack) to be copied into the instance for remote SSH access
      private: false

    - name: private_keypair_path
      prompt: path to the local private keypair to use for SSH access to the instance. Or press Enter to accept default
      private: false
      default: "~/.ssh/id_rsa"

    - name: private_network_name
      prompt: private network name to attach the instance to
      private: false

    - name: security_group_name
      prompt: security group name to apply to the instance
      private: false

    - name: whitelisted_ip_ranges
      prompt: IPv4 ranges (in CIDR format) to be whitelisted in Fail2ban configuration. When in doubt, do not set. Press Enter to skip
      private: false

  vars:
    ecmwf_defaults:
      external_network_name_fact: "external-internet"

    eumetsat_defaults:
      external_network_name_fact: "external"

  pre_tasks:
    - name: Validate user input
      ansible.builtin.assert:
        that:
          - ewc_provider is defined and ewc_provider != ''
          - ewc_provider | lower in ['ecmwf', 'eumetsat']
          - tf_project_path is defined and tf_project_path != ''
          - private_keypair_path is defined and private_keypair_path != ''
        fail_msg: "Input validation failed. See README.md for information on required inputs and their format."
        success_msg: "User input configuration is valid."

    - name: Store user input as localhost facts
      ansible.builtin.set_fact:
        tf_project_path_fact: "{{ tf_project_path }}"
        private_keypair_path_fact: "{{ private_keypair_path }}"
        defaults: >-
          {{
            ( ewc_provider == 'ecmwf' ) | ternary(ecmwf_defaults, eumetsat_defaults)
          }}

        ewc_tf_module_openstack_compute:
          app_name_fact: "{{ app_name }}"
          instance_name_fact: "{{ instance_name }}"
          instance_index_fact: "{{ instance_index }}"
          flavor_name_fact: "{{ flavor_name }}"
          image_name_fact: "{{ image_name }}"
          security_group_name_fact: "{{ security_group_name }}"
          public_keypair_name_fact: "{{ public_keypair_name }}"
          private_network_name_fact: "{{ private_network_name }}"

        ewc_ansible_role_remote_desktop:
          whitelisted_ip_ranges_fact: "{{ whitelisted_ip_ranges }}"

- name: Provision VM via Terraform and authorized OpenStack application credentials
  hosts: localhost
  connection: local
  gather_facts: false

  tasks:
    - name: Create Terraform working directory
      ansible.builtin.file:
        path: "{{ hostvars['localhost']['tf_project_path_fact'] }}"
        state: directory
        mode: "0644"

    - name: Customize Terraform module based on user inputs
      ansible.builtin.copy:
        dest: "{{ hostvars['localhost']['tf_project_path_fact'] }}/main.tf"
        mode: "0644"
        content: |
          # Generated by Ansible
          module "web_server" {
            source = "github.com/ewcloud/ewc-tf-module-openstack-compute?ref=1.4.0"

            app_name       = "{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['app_name_fact'] }}"
            instance_name  = "{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['instance_name_fact'] }}"
            instance_index = "{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['instance_index_fact'] }}"
            image_name     = "{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['image_name_fact'] }}"
            flavor_name    = "{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['flavor_name_fact'] }}"
            keypair_name   = "{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['public_keypair_name_fact'] }}"

            networks        = ["{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['private_network_name_fact'] }}"]
            security_groups = ["{{ hostvars['localhost']['ewc_tf_module_openstack_compute']['security_group_name_fact'] }}"]

            external_network_name = "{{ hostvars['localhost']['defaults']['external_network_name_fact'] }}"

            # NOTE: A floating IP is used in post-provisioning, for instance configuration
            # by Ansible via ssh from localhost. It'll be removed after successful start!
            instance_has_fip = true

            tags = {
              provisioning-tool = "terraform"
            }
          }

    - name: Gather Terraform execution facts
      ansible.builtin.copy:
        dest: "{{ hostvars['localhost']['tf_project_path_fact'] }}/outputs.tf"
        mode: "0644"
        content: |
          # Generated by Ansible
          output "instance" {
            value = "${module.web_server.instance}"
          }

    - name: Check if Terraform state file exists
      ansible.builtin.stat:
        path: "{{ hostvars['localhost']['tf_project_path_fact'] }}/terraform.tfstate"
      register: tfstate_file

    - name: Perform initial instance provisioning
      community.general.terraform:
        project_path: "{{ hostvars['localhost']['tf_project_path_fact'] }}"
        state: present
        force_init: true
        overwrite_init: false
        provider_upgrade: false
      register: tf_initialized_and_applied
      environment:
        TF_IN_AUTOMATION: "true"
      when: not tfstate_file.stat.exists

    - name: Update previously provisioned instance
      community.general.terraform:
        project_path: "{{ hostvars['localhost']['tf_project_path_fact'] }}"
        state: present
        force_init: false
        overwrite_init: false
        provider_upgrade: false
      register: tf_applied
      environment:
        TF_IN_AUTOMATION: "true"
      when: tfstate_file.stat.exists

    - name: Store private IP address of the newly provisioned OpenStack VM
      ansible.builtin.set_fact:
        remote_host_internal_ip_fact: "{{ tf_applied.outputs.instance.value.internal_ip if tfstate_file.stat.exists else tf_initialized_and_applied.outputs.instance.value.internal_ip }}"

    - name: Store public IP address of the newly provisioned OpenStack VM
      ansible.builtin.set_fact:
        remote_host_public_ip_fact: "{{ tf_applied.outputs.instance.value.floating_ip if tfstate_file.stat.exists else tf_initialized_and_applied.outputs.instance.value.floating_ip }}"

    - name: Store hostname of the newly provisioned OpenStack VM
      ansible.builtin.set_fact:
        remote_hostname_fact: "{{ tf_applied.outputs.instance.value.name if tfstate_file.stat.exists else tf_initialized_and_applied.outputs.instance.value.name }}"

    - name: Wait for SSH to become available
      ansible.builtin.wait_for:
        host: "{{ remote_host_public_ip_fact }}"
        port: 22
        timeout: 300

    - name: Add dynamic host to inventory
      ansible.builtin.add_host:
        name: "remote_host"
        ansible_host: "{{ remote_host_public_ip_fact }}"
        ansible_user: "cloud-user"
        ansible_ssh_private_key_file: "{{ hostvars['localhost']['private_keypair_path'] }}"
        ansible_ssh_common_args: "-o StrictHostKeyChecking=accept-new"

- name: Configure Remote Desktop server
  hosts: remote_host
  become: true
  become_user: root
  become_method: ansible.builtin.sudo
  tasks:
    - name: EWC Ansible Role Remote Desktop
      ansible.builtin.include_role:
        name: ewc-ansible-role-remote-desktop-1.0
      vars:
        whitelisted_ip_ranges: "{{ hostvars['localhost']['ewc_ansible_role_remote_desktop']['whitelisted_ip_ranges_fact'] }}"

- name: Cleanup and summarize execution after post-provisioning
  hosts: localhost
  connection: local
  gather_facts: false

  tasks:
    - name: Update intance's Terraform definition file
      ansible.builtin.lineinfile:
        path: "{{ hostvars['localhost']['tf_project_path_fact'] }}/main.tf"
        search_string: 'instance_has_fip'
        line: instance_has_fip = false
        mode: "0644"

    - name: Remove any unsolicited external IP addresses used during post-provisioning
      community.general.terraform:
        project_path: "{{ hostvars['localhost']['tf_project_path_fact'] }}"
        state_file: "{{ hostvars['localhost']['tf_project_path_fact'] }}/terraform.tfstate"
        state: present
        force_init: false
        overwrite_init: false
        provider_upgrade: false
      register: tf_applied
      environment:
        TF_IN_AUTOMATION: "true"

    - name: List created/edited OpenStack resources
      ansible.builtin.debug:
        msg:
          - "Terraform state file path: {{ hostvars['localhost']['tf_project_path_fact'] }}/terraform.tfstate"
          - "OpenStack instance name: {{ hostvars['localhost']['remote_hostname_fact'] }}"
          - "OpenStack internal IP address: {{ hostvars['localhost']['remote_host_internal_ip_fact'] }}"
          - "OpenStack public IP address: {{ 'N/A' }}"
